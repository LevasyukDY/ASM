format mz
org 100h

            ; Вывод на экран первой строки
            mov   ah, 09h        ; Сохраняем в регистр AH номер прерывания 09h - вывод строки символов на экран
            mov   dx, String1    ; Передаём параметр String1 - выводимая строка
            int   21h            ; Вызов программного прерывания MSDOS из регистра AH

            ; Перевод каретки на новую строку после вывода
            mov   ah, 02h        ; Сохраняем в регистр AH номер прерывания 02h - вывод символа на экран
            mov   dx, 0ah        ; Передаём параметр 0ah - ввод строки символов с клавиатуры с буферизацией
            int   21h            ; Вызов программного прерывания MSDOS


            ; Ввод символов с клавиатуры
            mov   ecx, 10        ; Счётчик цикла
            mov   di, 0          ; DI - индексовый регистр (будет хранить индексы массива)

LOOP_INPUTX:
            push  ecx            ; Сохраняем значение ECX в стэк, т.к. внутри процедуры будем работать с регистром CX
            call  InputNumber    ; Вызываем подпрограмму ввода с клавиатуры (помещаем стек адрес следующей команды)
            mov   [arrX+di], cx  ; Помещаем возвращаемое значение из CX в массив arrX
            pop   ecx            ; Извлекаем значение ECX из стэка
            add   di, 2          ; Увеличиваем индекс на 2
            loop  LOOP_INPUTX    ; Конец цикла (декремент регистра ECX; если ECX=0, то переход к следующей команде после loop)


            ;Вывод на экран второй строки
            mov   ah, 09h        ; Сохраняем в регистр AH номер прерывания 09h - вывод строки символов на экран
            mov   dx, String2    ; Передаём параметр String2 - выводимая строка
            int   21h            ; Вызов программного прерывания MSDOS из регистра AH

            ;Перевод каретки на новую строку после вывода
            mov   ah, 02h        ; Сохраняем в регистр AH номер прерывания 02h - вывод символа на экран
            mov   dx, 0ah        ; Передаём параметр 0ah - ввод строки символов с клавиатуры с буферизацией
            int   21h            ; Вызов программного прерывания MSDOS


            ; Ввод символов с клавиатуры
            mov   ecx, 10        ; Счётчик цикла
            mov   di, 0          ; DI - индексовый регистр (будет хранить индексы массива)

LOOP_INPUTY:
            push  ecx            ; Сохраняем значение ECX в стэк, т.к. внутри процедуры будем работать с регистром CX
            call  InputNumber    ; Вызываем подпрограмму ввода с клавиатуры (помещаем стек адрес следующей команды)
            mov   [arrY+di], cx  ; Помещаем возвращаемое значение из CX в массив arrY
            pop   ecx            ; Извлекаем значение ECX из стэка
            add   di, 2          ; Увеличиваем индекс на 2
            loop  LOOP_INPUTY    ; Конец цикла (декремент регистра ECX; если ECX=0, то переход к следующей команде после loop)


            ; Цикл подсчёта длин десятиугольника и занесение их в массив arrL
            mov   ecx, 10        ; Счётчик цикла
            mov   di, 0          ; DI - индексовый регистр (будет хранить индексы массива)
            mov   ax, [arrX+0]   ; Помещаем в регистр AX первый эл-т массива arrX
            mov   [arrX+20], ax  ; Значение из регистра AX присваиваем последнему эл-ту массива arrX
            mov   ax, [arrY+0]   ; Помещаем в регистр AX первый эл-т массива arrY
            mov   [arrY+20], ax  ; Значение из регистра AX присваиваем последнему эл-ту массива arrY

LOOP_CALC:
            push  ecx            ; Сохраняем значение ECX в стэк, т.к. внутри процедуры будем работать с регистром CX
            call  CalcLength     ; Вызываем подпрограмму подсчёта длины между двумя точками (помещаем стек адрес следующей команды)
            mov   [arrL+di], ax  ; Помещаем результат подпрограммы в массив arrL
            add   di, 2          ; Увеличиваем индекс на 2
            pop   ecx            ; Извлекаем значение ECX из стэка
            loop  LOOP_CALC      ; Конец цикла (декремент регистра ECX; если ECX=0, то переход к следующей команде после loop)


            ; Цикл подсчёта периметра (суммы длин) десятиугольника
            mov   ecx, 9         ; Счётчик цикла
            mov   di, 2          ; DI - индексовый регистр (будет хранить индексы массива)
            mov   ax, [arrL+0]   ; Помещаем в регистр AX первый эл-т массива arrL

LOOP_SUM:
            adc   ax, [arrL+di]  ; ADC - команда сложения без потери старшего бита при переполнении разрядной сетки (O1 = O1+O2+CF)
            add   di, 2          ; Увеличиваем индекс на 2
            loop  LOOP_SUM       ; Конец цикла (декремент регистра ECX; если ECX=0, то переход к следующей команде после loop)

            jmp end_prog         ; Безусловный переход к метке end_prog


;----------------ИСПОЛЬЗУЕМЫЕ ПОДПРОГРАММЫ---------------------------------------------------------------------------------------\

; Подсчёт длины между двумя точками
CalcLength:
            ; x := sqr(x2-x1)
            mov   ax, [arrX+di]    ; AX хранит значение первого эл-та массива arrX
            mov   bx, [arrX+di+2]  ; BX хранит значение второго эл-та массива arrX
            sbb   bx, ax           ; Вычитание первого эл-та из второго с займом (O1 = O1-O2-CF)
            imul  bx, bx           ; Возведение в квадрат
            mov   [x], bx          ; Результат операций в переменной 'x'

            ; y := sqr(y2-y1)
            mov   ax, [arrY+di]    ; AX хранит значение первого эл-та массива arrY
            mov   bx, [arrY+di+2]  ; BX хранит значение второго эл-та массива arrY
            sbb   bx, ax           ; Вычитание первого эл-та из второго с займом (O1 = O1-O2-CF)
            imul  bx, bx           ; Возведение в квадрат
            mov   [y], bx          ; Результат операций в переменной 'y'

            ; sqrt(x+y)
            mov   ax, [x]          ; Помещаем в регистр AX результат sqr(x2-x1)
            adc   ax, [y]          ; Складываем значение регистра AX с результатом sqr(y2-y1) без потери старшего бита...
                                   ; ...при переполнении разрядной сетки (O1 = O1+O2+CF)
            mov   [x], ax          ; Помещаем в переменную 'x' результат сложения x+y
            finit                  ; Инициализируем FPU - набор команд процессора для работы с вещественной арифметикой
            fild  [x]              ; Загружает целое число в стек сопроцессора
            fsqrt                  ; Вычисление квадратного корня (берёт корень из числа, находящегося в вершине стека сопроцессора)...
                                   ; ...результат операции сохраняется в регистре ST(0) - вершина стека
            fist  [result]         ; Результат из ST(0) помещаем в переменную result
            mov   ax, [result]     ; Помещаем значение из result в регистр AX
            ret                    ; Передача управления по адресу, расположенному в вершине стека (адрес помещается в стек командой CALL...
                                   ; ...и его значение соответствует команде, следующей за командой CALL


; Подпрограмма ввода с клавиатуры строки и преобразование в число
InputNumber:
            mov   ah, 01h  ; Сохраняем в регистр AH номер прерывания 01h - ввод одного символа с клавиатуры с echo на экран
            int   21h      ; Вызов программного прерывания MSDOS из регистра AH

            cmp al, '-'    ; CMP - аналог SUB, но результат никуда не сохраняется, команда изменяет флаги
            je MINUS       ; Если ZF=1 (AL = '-'), то переход на метку MINUS

            sub   al, 30h  ; Преобразование символа в цифру (код цифры находится в таблице ASCII от символа этой цифры на 30 меньше)
            mov   ah, 0h   ; Расширение до слова
            mov   bx, 10   ; Множитель для многоразрядных чисел
            mov   cx, ax   ; Первая цифра сохраняется в CX

            ; Цикл ввода остальной части числа
      Input:
            mov   ah, 01h  ; Сохраняем в регистр AH номер прерывания 01h - ввод одного символа с клавиатуры с echo на экран
            int   21h      ; Вызов программного прерывания MSDOS из регистра AH

            cmp   al, 0dh  ; CMP - аналог SUB, но результат никуда не сохраняется, команда изменяет флаги
            je    EndInput ; Если ZF=1 (AL = Enter), то переход на метку EndInput (выход из цикла если нажат Enter)

            sub   al, 30h  ; Преобразование символа в цифру (код цифры находится в таблице ASCII от символа этой цифры на 30 меньше)
            mov   ah, 0h   ; Расширение до слова

            xchg  ax, cx   ; Обменяемся значениями м/у ах и сх
            mul   bx       ; Увеличим разрядность вводимого числа
            add   cx, ax   ; Сложим введённые числа

            jmp   Input    ; Безусловный переход к метке Input

            ; Переход на эту метку если был введён минус
      MINUS:
            mov   ah, 01h  ; Сохраняем в регистр AH номер прерывания 01h - ввод одного символа с клавиатуры с echo на экран
            int   21h      ; Вызов программного прерывания MSDOS из регистра AH

            sub   al, 30h  ; Преобразование символа в цифру (код цифры находится в таблице ASCII от символа этой цифры на 30 меньше)
            mov   ah, 0h   ; Расширение до слова
            mov   bx, 10   ; Множитель для многоразрядных чисел
            mov   cx, ax   ; Первая цифра сохраняется в CX

            mov   si, 1    ; Устанавливаем в индексовый регистр SI единицу для обозначения отрицательного числа
            jmp   Input    ; Безусловный переход к метке Input

            ; Конец ввода числа
   EndInput:
            ;Перевод каретки на новую строку после ввода
            mov   ah, 02h  ; Сохраняем в регистр AH номер прерывания 02h - вывод символа на экран
            mov   dx, 0ah  ; Передаём параметр 0ah - ввод строки символов с клавиатуры с буферизацией
            int   21h      ; Вызов программного прерывания MSDOS из регистра AH

            cmp   si, 1    ; CMP - аналог SUB, но результат никуда не сохраняется, команда изменяет флаги
            jne   END_END  ; Если ZF=0 (SI != 1), то переход на метку END_END

            neg   cx       ; Преобразует положительное число в отрицательное
            mov   si, 0    ; Обнуление регистра SI

    END_END:
            ret            ; Передача управления по адресу, расположенному в вершине стека (адрес помещается в стек командой CALL...
                           ; ...и его значение соответствует команде, следующей за командой CALL


; Подпрограмма вывода результата (конец программы)
end_prog:
            mov bl, 10      ; Помещаем в BL делитель
            mov dx, ax      ; Помещаем в DX выводимое число, которое хранится в AX
            mov dh, 0       ; Обнуляем DH
            mov di, String3 ; Помещаем в DI адрес STOSB

            add di, 9       ; Увеличиваем DI на длину строки
            mov al, '$'     ; Помещаем в регистр AL символ '$' (конца строки)
            mov ah, 0       ; Расширение до слова
            push ax         ; Передача значения регистра AX в стек

     label1:
            mov ax, dx      ; Помещаем в AX, значение регистра DX
            div bl          ; Делим AX на 10 (помещённую в регистре BL, частное в AL)
            mov dl, al      ; Помещаем частное в DL, остаток хранится в AH
            mov dh, 0       ; Обнуляем DH

            mov al, ah      ; Помещаем в регистр AL значение регистра AH
            add al, 0x30    ; Преобразование цифры в символ (код символа цифры находится в таблице ASCII от самой цифры на 30 больше)
            mov ah, 0       ; Расширение до слова
            push ax         ; Передача значения регистра AX в стек

            cmp dl, 0       ; Зацикливание label1
            jne label1      ; Если ZF=0 (DL != 0), то переход на метку label1

     label2:
            pop ax          ; Извлечение из стека значения и передача в AX
            stosb           ; Запись строки в память (возьмёт из AL код символа)
            cmp al, '$'     ; CMP - аналог SUB, но результат никуда не сохраняется, команда изменяет флаги
            jne label2      ; Если ZF=0 (AL != '$'), то переход на метку label2

            mov ah, 09h     ; Сохраняем в регистр AH номер прерывания 09h - вывод строки символов на экран
            mov dx, String3 ; Передаём параметр String3 - выводимая строка
            int 21h         ; Вызов программного прерывания MSDOS из регистра AH

            mov ah, 01h     ; Сохраняем в регистр AH номер прерывания 01h - ввод одного символа с клавиатуры с echo на экран
            int 21h         ; Вызов программного прерывания MSDOS из регистра AH

            mov ah, 4ch     ; Сохраняем в регистр AH номер прерывания 4ch - штатное завершение процесса с возвратом урпавления
            int 21h         ; Вызов программного прерывания MSDOS из регистра AH

            ;Ожидаем нажатия клавиши
            mov   ah, 01h   ; Сохраняем в регистр AH номер прерывания 01h - ввод одного символа с клавиатуры с echo на экран
            int   21h       ; Вызов программного прерывания MSDOS из регистра AH
            int   20h       ; Выходим из программы


;----------------ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ---------------------------------------------------------------------------------------\

String1 db 'Enter the values x1,x2,..,x10: $'   ; Выделяем 1 байт под переменную String1
String2 db 'Enter the values y1,y2,..,y10: $'   ; Выделяем 1 байт под переменную String2
String3 db 'Result = '                          ; Выделяем 1 байт под переменную String3
arrX    dw 11 dup(0)    ; Резервируем 11 ячеек памяти, размером 2 байта, запишем в них нули и свяжем с arrX
arrY    dw 11 dup(0)    ; Резервируем 11 ячеек памяти, размером 2 байта, запишем в них нули и свяжем с arrY
arrL    dw 11 dup(0)    ; Резервируем 11 ячеек памяти, размером 2 байта, запишем в них нули и свяжем с arrL
x       dw ?            ; Выделяем 2 байта под переменную 'x' для временного хранения значения внутри подпрограммы CalcLength
y       dw ?            ; Выделяем 2 байта под переменную 'y' для временного хранения значения внутри подпрограммы CalcLength
result  dw ?            ; Выделяем 2 байта под переменную result для временного хранения результата внутри подпрограммы CalcLength








